# 🎨 架构可视化对比

## 模式 1: 直连模式（当前实现）

```
┌─────────────────────────────────────────────────────────────────────┐
│                        用户浏览器                                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  index.html (前端代码)                                       │   │
│  │                                                             │   │
│  │  const ws = new WebSocket('ws://127.0.0.1:18789');          │   │
│  │  ws.send({                                                  │   │
│  │    method: 'connect',                                       │   │
│  │    params: {                                                │   │
│  │      auth: {                                                │   │
│  │        token: '99a1282cff39...'  ← TOKEN 暴露在这里！        │   │
│  │      }                                                      │   │
│  │    }                                                        │   │
│  │  });                                                        │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
                                 │
                                 │ WebSocket 连接
                                 │ (前端知道 token)
                                 ↓
┌─────────────────────────────────────────────────────────────────────┐
│  OpenClaw Gateway                                                  │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  验证 token                                                   │   │
│  │  处理消息                                                     │   │
│  │  返回响应                                                     │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘

**问题**：
❌ Token 在浏览器 JavaScript 代码中可见
❌ 开发者工具可以看到 token
❌ XSS 攻击可以窃取 token
❌ 无法限制访问权限
```

---

## 模式 2: 代理模式（安全方案）

```
┌─────────────────────────────────────────────────────────────────────┐
│                        用户浏览器                                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  index.html (前端代码)                                       │   │
│  │                                                             │   │
│  │  const ws = new WebSocket('ws://localhost:36006/ws');       │   │
│  │  // 连接到 Go 后端，不需要 token！                           │   │
│  │  ws.send({                                                  │   │
│  │    method: 'chat.send',                                     │   │
│  │    params: { message: 'Hello' }                             │   │
│  │  });                                                        │   │
│  │                                                             │   │
│  │  // ✅ 前端完全不知道 token！                                │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
                                 │
                                 │ WebSocket 连接
                                 │ (无 token)
                                 ↓
┌─────────────────────────────────────────────────────────────────────┐
│  Go 后端服务器 (Proxy Mode)                                         │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  1. 接受前端连接                                              │   │
│  │     frontendConn := upgrader.Upgrade(w, r, nil)             │   │
│  │                                                             │   │
│  │  2. 连接到 Gateway (使用 token)                              │   │
│  │     backendConn := dial("ws://127.0.0.1:18789")             │   │
│  │     backendConn.send({                                      │   │
│  │       auth: {                                               │   │
│  │         token: '99a1282cff39...'  ← TOKEN 在这里！           │   │
│  │       }                                                      │   │
│  │     })                                                       │   │
│  │                                                             │   │
│  │  3. 双向转发消息                                              │   │
│  │     go frontendToBackend()   // 前端 → Gateway              │   │
│  │     go backendToFrontend()   // Gateway → 前端              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                 ↑                                   │
│                                 │ Token 隐藏在这里                  │
│                                 │                                  │
└─────────────────────────────────┼───────────────────────────────────┘
                                  │
                                  │ WebSocket 连接
                                  │ (后端持有 token)
                                  ↓
┌─────────────────────────────────────────────────────────────────────┐
│  OpenClaw Gateway                                                  │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  验证 token（从 Go 后端发送的）                               │   │
│  │  处理消息                                                     │   │
│  │  返回响应                                                     │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘

**优点**：
✅ Token 完全隐藏在后端
✅ 前端 JavaScript 代码中没有 token
✅ 浏览器开发者工具看不到 token
✅ 可添加用户认证层
✅ 可记录审计日志
```

---

## 🔑 Token 位置对比

### 直连模式

```javascript
// 浏览器源代码（view-source）
const ws = new WebSocket('ws://127.0.0.1:18789');
ws.send(JSON.stringify({
  method: 'connect',
  params: {
    auth: {
      token: '99a1282cff39ec6008916016302302fe42dd769c6d1fdfc1'
      // ↑ 任何人都可以看到！
    }
  }
}));
```

**检查方式**：
1. 打开浏览器开发者工具（F12）
2. 查看 Network 标签
3. 找到 WebSocket 连接
4. 查看发送的消息 → **Token 暴露！**

---

### 代理模式

```javascript
// 浏览器源代码（view-source）
const ws = new WebSocket('ws://localhost:36006/ws');
ws.send(JSON.stringify({
  method: 'chat.send',
  params: {
    message: 'Hello'
    // ↑ 没有 token！
  }
}));
```

**检查方式**：
1. 打开浏览器开发者工具（F12）
2. 查看 Network 标签
3. 找到 WebSocket 连接（ws://localhost:36006/ws）
4. 查看发送的消息 → **只有消息内容，没有 token！**

Token 在哪里？
```go
// Go 后端代码（服务器端，用户无法访问）
func connectToGateway(gateway GatewayConfig) *websocket.Conn {
    conn, _ := websocket.DefaultDialer.Dial(gateway.URL, nil)
    conn.WriteJSON(map[string]interface{}{
        "type": "req",
        "method": "connect",
        "params": map[string]interface{}{
            "auth": map[string]string{
                "token": "99a1282cff39ec6008916016302302fe42dd769c6d1fdfc1"
                // ↑ Token 在后端，前端看不到！
            }
        },
    })
    return conn
}
```

---

## 📊 安全对比表

| 方面 | 直连模式 | 代理模式 |
|------|----------|----------|
| **Token 位置** | 前端 JavaScript | 后端 Go 代码 |
| **浏览器可见性** | ✅ 可见（F12 可查） | ❌ 不可见 |
| **源代码暴露** | ✅ 暴露（view-source） | ❌ 不暴露 |
| **XSS 风险** | ⚠️ 高（脚本可窃取） | ✅ 低（无 token 可窃取） |
| **用户认证** | ❌ 无法实现 | ✅ 可在代理层实现 |
| **审计日志** | ❌ 无法记录 | ✅ 可记录所有消息 |
| **访问控制** | ❌ 无法限制 | ✅ 可限制用户/会话 |
| **实现复杂度** | ⭐ 简单 | ⭐⭐⭐ 中等 |
| **维护成本** | ⭐ 低 | ⭐⭐ 中 |

---

## 🎯 消息流对比

### 直连模式的消息流

```
1. 浏览器建立连接
   Browser ──WebSocket──▶ Gateway
   发送: { type: 'req', method: 'connect', params: { auth: { token: '...' } } }

2. 浏览器发送消息
   Browser ─────────────────────▶ Gateway
   发送: { method: 'chat.send', params: { message: 'Hello' } }

3. Gateway 返回响应
   Gateway ─────────────────────▶ Browser
   返回: { type: 'event', event: 'agent', payload: { ... } }
```

**问题**：第 1 步中，浏览器直接发送 token 到 Gateway

---

### 代理模式的消息流

```
1. 浏览器建立连接（无 token）
   Browser ──WebSocket──▶ Go Proxy
   发送: (连接请求，无认证信息)

2. Go Proxy 连接 Gateway（带 token）
   Go Proxy ──WebSocket──▶ Gateway
   发送: { type: 'req', method: 'connect', params: { auth: { token: '...' } } }
         ↑ Token 在这里！浏览器看不到

3. 浏览器发送消息
   Browser ───────────────▶ Go Proxy ───────────────▶ Gateway
   发送: { method: 'chat.send', params: { message: 'Hello' } }

4. Gateway 返回响应
   Gateway ──────────────▶ Go Proxy ────────────────▶ Browser
   返回: { type: 'event', event: 'agent', payload: { ... } }
```

**优点**：第 2 步中，只有 Go Proxy 知道 token，浏览器看不到

---

## 💻 代码量对比

### 直连模式（当前）

- **前端代码**：~200 行（HTML + JavaScript）
- **后端代码**：~100 行（main.go，只提供静态文件）
- **总计**：~300 行

### 代理模式

- **前端代码**：~200 行（HTML + JavaScript，简化版）
- **后端代码**：~300 行（main.go，WebSocket 代理逻辑）
- **总计**：~500 行

**增加**：~200 行（主要是后端代理逻辑）

---

## 🚀 切换成本

### 从直连模式 → 代理模式

1. **修改 Go 后端**（~200 行）
   - 添加 WebSocket 代理逻辑
   - 添加 gorilla/websocket 依赖

2. **修改前端代码**（~10 行）
   - 修改 WebSocket 连接地址
   - 移除 token 认证代码

3. **测试验证**
   - 确保消息正确转发
   - 确认 token 隐藏

**估计时间**：2-4 小时

---

## ❓ 你需要代理模式吗？

### 推荐使用代理模式的情况：

✅ **公网部署** - 任何人都可以访问你的网站
✅ **多用户** - 不同用户使用不同的账号
✅ **安全要求高** - Token 有权限限制，不能泄露
✅ **需要审计** - 需要记录所有消息日志
✅ **需要认证** - 需要实现登录、权限控制

### 可以保持直连模式的情况：

✅ **个人使用** - 只有你自己使用
✅ **内网部署** - 只有内部人员访问
✅ **测试环境** - Token 是临时的
✅ **简单快速** - 不想增加复杂度

---

## 📝 总结

**代理模式的核心价值**：
- 🔒 Token 安全：完全隐藏在后端
- 🛡️ 可扩展性：可添加认证、权限控制
- 📊 可审计性：可记录所有消息

**代价**：
- 💻 增加复杂度（~200 行代码）
- 🐛 需要处理更多边界情况
- 📈 稍微增加维护成本

**建议**：
- 如果是**个人使用/测试** → 保持直连模式
- 如果要**公网部署/多用户** → 切换到代理模式

---

**需要我帮你实现完整的代理模式吗？** 还是保持当前的直连模式？
